SPOS Practical 1
pass 1-
/*  
 *  Program for Pass I of Two-Pass Assembler
 *  Programmer Ms. Jaishri Panchal
 * *
 */

package Part1GroupAPass1;

class symtab{
	int index;
	String name;
	int addr;
	
	
	symtab(int i, String s, int a){
		index = i;
		name = s;
		addr = a;
	}
}

class littab{
	int index;
	String name;
	int addr;
	
	littab(int i, String s, int a){
		index = i;
		name = s;
		addr = a;
		
	}
	
	void setaddr(int a) {
		addr = a;
	}
}

class pooltab{
	int p_index;
	int l_index;
	
	pooltab(int i, int a){
		p_index = i;
		l_index = a;
	}
}


public class pass1 {

	public static void main(String args[]) {
		
		String input[][] = {
				{null, "START", "100", null},
				{null, "MOVER", "AREG", "A"},
				
				{"AGAIN", "ADD", "AREG", "='2"},
				{null, "ADD", "AREG", "B"},
				
				{"AGAIN", "ADD", "AREG", "='3"},
				{null, "LTORG", null, null},
				
				{"AGAIN2", "ADD", "AREG", "BREG"},
				
				{"AGAIN2", "ADD", "AREG", "CREG"},
				
				{"AGAIN", "ADD", "AREG", "='2"},
				{null, "DC", "B", "3"},
				{"LOOP", "DS", "A", "1"},
				{null, "END", null, null}
		};
		
		symtab s[] = new symtab[20];
		littab l[] = new littab[20];
		pooltab p[] = new pooltab[20];
		
		int loc=0, i=0;
		String m, op1, op2;
		
		int sn=0, ln=0, lnc=0, pn=0;
		
		loc = Integer.parseInt(input[0][2]);
		
		m = input[1][1];
		i = 1;
		
		while (!m.equals("END")) {
			if (check(m) == 1) {
				if (input[i][0] == null) {
					op1 = input[i][2];
					op2 = input[i][3];
					if (comp(op2, s, sn) == 1) {
						s[sn] = new symtab(sn, op2,  0);
						sn++;
					}
					else if (comp(op2, s, sn) == 2) {
						l[ln] = new littab (ln,op2, 0);
						ln++;
					}
					loc++;
					i++;
				}
				else {
					op1 = input[i][0];
					s[sn] = new symtab(sn, op1,loc);
					sn++;
					
					op1 = input[i][2];
					op2 = input[i][3];
					
					if (comp(op2, s, sn) == 1) {
						s[sn] = new symtab(sn, op2, 0);
						sn++;
					}
					else if (comp(op2, s, sn) == 2) {
						l[ln] = new littab(ln, op2, 0);
						ln++;
					}
					loc++;
					i++;
				}
			}
			else if (check(m) == 2) {
				if(input[i][0] == null) {
					int temp;
					op1 = input[i][2];
					op2 = input[i][3];
					temp = comps(op1, s, sn);
					if (temp != 99) {
						s[temp] = new symtab(temp, op1, loc);
				
					}
					loc = loc + Integer.parseInt(op2);
					i++;
				}
				else {
					int temp;
					op1 = input[i][0];
					s[sn] = new symtab(sn, op1, loc);
					sn++;
					
					op1 = input[i][2];
					op2 = input[i][3];
					temp = comps(op1, s, sn);
					if (temp != 99) {
						s[temp] = new symtab(temp, op1, loc);
					}
					loc = loc + Integer.parseInt(op2);
					i++;
				}
			}
			else if (check(m) == 3) {
				if(input[i][0] == null) {
					int temp;
					op1 = input[i][2];
					op2 = input[i][3];
					temp = comps(op1, s, sn);
					if (temp !=99) {
						s[temp] = new symtab(temp, op1, loc);
					}
					loc++;
					i++;
				}
				else {
					int temp;
					op1 = input[i][0];
					s[sn] = new symtab(sn, op1, loc);
					sn++;
					
					op1 = input[i][2];
					op2 = input[i][3];
					temp = comps(op1, s, sn);
					if (temp != 99) {
						s[temp] = new symtab(temp, op1, loc);
					}
					loc++;
					i++;
				}
			}
			else if (check(m) == 4) {
				if(lnc != ln) {
					p[pn] = new pooltab(pn,lnc);
					pn++;
				}
				while (lnc != ln) {
					l[lnc].setaddr(loc);
					lnc++;
					loc++;
				}
				i++;
			}
			m = input [i][1];
		}
		if (lnc != ln) {
			p[pn] = new pooltab(pn,lnc);
			pn++;
		}
		while (lnc != ln) {
			l[lnc].setaddr(loc);
			lnc++;
			loc++;
		}
		System.out.println("Symbol Table\nIndex\tSymbol\tAddress\n");
		
		for (i=0; i<sn; i++) {
			System.out.println(s[i].index + "\t" + s[i].name + "\t" + s[i].addr);
		}
		System.out.println("\nLiteral Table\nIndex\tLiteral\tAddress\n");
		for (i=0; i<ln; i++) {
			System.out.println(l[i].index + "\t" + l[i].name + "\t" + l[i].addr);
		}
		System.out.println("\nPool Table\nPool Index\tLiteral Index\n");
		for (i=0; i<pn; i++) {
			System.out.println("\t" + p[i].p_index + "\t\t" + p[i].l_index);
		}
		System.out.println("\n\nIntermediate Code\n");
		i=0;
		m = input[i][1];
		op1 = input[i][2];
		op2 = input[i][3];
		
		int point = 0, in1, in2, j=0;
		
		System.out.println(ic(m) + ic(op1));
		while (!m.equals("END")) {
			if (check(m) == 1) {
				System.out.println(ic(m) + ic(op1));
				if (comp(op2,s,sn) == 0 && comps(op2, s, sn) == 99) {
					System.out.println(ic(op2));
				}
				else if (comp(op2, s, sn) == 2) {
					int temp;
					temp = compl(op2, l, ln, j);
					System.out.println("(L," + temp + ")");
					j++;
				}
				else if (comp(op2, s, sn) != 1) {
					int temp;
					temp = comps(op2, s, sn);
					System.out.println("S," + temp + ")");
				}
			}
			else if (check(m) == 2 || check(m) == 3) {
				System.out.println(ic(m) + ic(op2));
				/*if (comp(op1, s, sn) != 1) {
					int temp;
					temp = comps(op1, s, sn);
					System.out.println("(S," + temp + ")");
				}*/
			}
			else if (check(m) == 4) {
				if (point+1 != pn) {
					in1 = p[point+1].l_index - p[point].l_index;
						
					in2 = p[point].l_index;
					point++;
						
					while (in1>0) {
						System.out.println(ic(m) + ic(l[in2].name));
						in2++;
						in1--;
						System.out.println("\n");
					}
				}
				else {
					in2 = p[point].l_index;
					while (in2 != ln) {
						System.out.println(ic(m) + ic(l[in2].name));
						in2++;
						System.out.println("\n");
					}
				}
			}
			i++;
			m = input[i][1];
			op1 = input[i][2];
			op2 = input[i][3];
			System.out.println("\n");
		}
		System.out.println(ic(m));
		m = "LTORG";
		if (point+1 != pn) {
			in1 = p[point+1].l_index - p[point].l_index;
			in2 = p[point].l_index;
			point++;
			while (in1 > 0) {
				System.out.println(ic(m) + ic(l[in2].name));
				in2++;
				in1--;
			}
		}
		else {
			in2 = p[point].l_index;
			while (in2 != ln) {
				System.out.println(ic(m) + ic(l[in2].name));
				in2++;
			}
		}
	}
			
	static int check(String m) {
		if (m.equals("MOVER") || m.equals("ADD")) {
			return 1;
		}
		else if (m.equals("DS")) {
			return 2;
		}
		else if (m.equals("DC")) {
			return 3;
		}
		else if (m.equals("LTORG")) {
			return 4;
		}
		return -1;
	}
	
	static int comp(String m, symtab s[], int sn) {
			if (m.equals("AREG") || m.equals("BREG") || m.equals("CREG")) 
				return 0;
			else if (m.toCharArray()[0] == '=')
				return 2;
			else if (comps(m, s, sn) == 99)
				return 1;
			else
				return 0;
	}
	
	static int compl(String m, littab l[], int ln, int j) {
		int i;
		for (i=j; i<ln; i++) {
			if (m.equals(l[i].name)) 
				return l[i].index;
		}
		return 99;
	}

	static int comps(String m, symtab s[], int sn) {
		int i;
		for (i=0; i<sn; i++) {
			if (m.equals(s[i].name))
				return s[i].index;
		}
		return 99;
	}
	
	static String ic(String m) {
		if (m == "START")
			return "(AD, 01)";
		else if ( m == "END")
			return "(AD, 02)";
		else if ( m == "ORIGIN")
			return "(AD, 03)";
		else if ( m == "EQU")
			return "(AD, 04)";
		else if ( m == "LTORG")
			return "(DL, 02)";
		else if ( m == "ADD")
			return "(IS, 01)";
		else if ( m == "SUB")
			return "(IS, 02)";
		else if ( m == "MOVER")
			return "(IS, 04)";
		else if ( m == "MOVEM")
			return "(AD, 05)";
		else if ( m == "AREG")
			return "(RG, 01)";
		else if ( m == "BREG")
			return "(RG, 02)";
		else if ( m == "CREG")
			return "(RG, 03)";
		else if ( m == "DS")
			return "(DL, 01)";
		else if ( m == "DC")
			return "(DL, 02)";
		else if (m.toCharArray()[0] == '=')
			return ( "(C," + m.toCharArray()[2] + ")" );
		else {
			return ("(C," + m + ")");
			
		}		
	}
}

pass 2
/*  
 *  Program for Pass II of Two-Pass Assembler
 *  Programmer Ms. Jaishri Panchal
 * *
 */

package Part1GroupAPass2;

import java.text.DecimalFormat;
class symtab{
	int index;
	String name;
	int addr;
	
	symtab(int i, String s, int a){
		index = i;
		name = s;
		addr = a;
	}
}

class littab{
	int index;
	String name;
	int addr;
	
	littab(int i, String s, int a){
		index = i;
		name = s;
		addr = a;
	}
	
	void setaddr(int a) {
		addr = a;
	}
}

public class pass2{
	public static void main(String[] args) {
		String ic[][] = {
				{"(AD,01)", null, "(C,100)"},
				
				{"(IS,04)", "(RG,01)", "(L,0)"},
				{"(IS,01)", "(RG,03)", "(L,1)"},
				
				{"(DL,01)", null, "(C,3)"},
				
				{"(IS,04)", "(RG,01)", "(S,2)"},
				{"(IS,01)", "(RG,01)", "(S,3)"},
				{"(IS,05)", "(RG,01)", "(S,4)"},
				
				{"(DL,02)", null, "(C,5)"},
				{"(DL,02)", null, "(C,1)"},
				
				{"(AD,04)", null, "(C, 103)"},
				
				{"(IS,10)", null, "(S,4)"},
				
				{"(AD,03)", null, "(C,101)"},
				
				{"(IS,02)", "(RG,01)", "(L,2)"},
				{"(IS,03)", "(RG,03)", "(S,2)"},
				
				{"(DL,02)", null, "(C,5)"},
				{"(AD,03)", null, "(C,111)"},
				{"(IS,00)", null, null},
				{"(DL,02)", null, "(C,19)"},
				{"(AD,02)", null, null},
				{"(DL,02)", null, "(C,1)"}
		};
		
		symtab s[] = new symtab[20];
		littab l[] = new littab[20];
		
		s[0] = new symtab(0, "A", 102);
		s[1] = new symtab(1, "L1", 105);
		s[2] = new symtab(2, "B", 112);
		s[3] = new symtab(3, "C", 103);
		s[4] = new symtab(4, "D", 103);
		
		l[0] = new littab(0, "='5'", 108);
		l[1] = new littab(1, "='1'", 109);
		l[2] = new littab(2, "='1'", 113);
		
		int i=0, j=0, ind=0;
		String m, op1,op2, temp;
		char arr1[], arr2[], arr3[];
		
		DecimalFormat df = new DecimalFormat("000");
		
		while (i < ic.length) {
			temp = null;
			arr1 = null;
			arr2 = null;
			arr3 = null;
			m = ic[i][0];
			op1 = ic[i][1];
			op2 = ic[i][2];
			
			arr1 = m.toCharArray();
			if (op1 != null) {
				arr2 = op1.toCharArray();
			}
			if (op2 != null) {
				arr3 = op2.toCharArray();
			}
			if (arr1[1] == 'I' && arr1[2] == 'S') {
				System.out.print(arr1[4] + "" + arr1[5] + "\t");
				if (op1 != null) {
					System.out.print(arr2[4] + "" + arr2[5] + "\t");
				}
				else {
					System.out.print("00" + "\t");
				}
				if (op2 != null) {
					if (arr3[1] == 'R' && arr3[2] == 'G') {
						System.out.print(arr3[4] + arr3[5] + "\t");
					}
					else if (arr3[1] == 'S') {
						ind = Character.getNumericValue(arr3[3]);
						j=4;
						while ( arr3[j] != ')' ) {
							ind = ind * 10;
							ind = ind + ( Character.getNumericValue(arr3[j]) );
							j++;
						}
						System.out.print(s[ind].addr + "\t");
					}
					else if (arr3[1] == 'L') {
						ind = Character.getNumericValue(arr3[3]);
						j = 4;
						while (arr3[j] != ')') {
							ind = ind * 10;
							ind = ind + ( Character.getNumericValue(arr3[j]) );
							j++;
						}
						System.out.print(l[ind].addr + "\t");
					}
				}
				else {
					System.out.print("000" + "\t");
				}
			}
			else if (arr1[1] == 'D' && arr1[2] == 'L') {
				if (arr1[5] == '2') {
					System.out.print("00\t00\t");
					j=3;
					while (arr3[j] != ')') {
						if (temp == null)
							temp = String.valueOf(arr3[j]);
						else
							temp = temp.concat(String.valueOf(arr3[j]));
						
						j++;
					}
					System.out.print(df.format(Integer.parseInt(temp)));
				}
			}
			i++;
			System.out.print("\n");
		}
	}
}

SPOS Practical 3 FCFS
//package Part1GroupB5FCFS;

import java.util.Scanner;

class fcfs{
	public static void main(String args[]){
		int burst_time[],process[],waiting_time[],tat[],i,j,n,total=0,pos,temp;
		float wait_avg, TAT_avg;
		Scanner s = new Scanner(System.in);
		System.out.print("Enter number of process: ");
		n = s.nextInt();
		process = new int[n];
		burst_time = new int[n];
		waiting_time = new int[n];
		tat = new int[n];
		System.out.println("\nEnter Burst time:");
		for(i=0;i<n;i++)
		{
			System.out.print("\nProcess["+(i+1)+"]: ");
			burst_time[i] = s.nextInt();;
			process[i]=i+1; //Process Number
		}
		//First process has 0 waiting time
		waiting_time[0]=0;
		//calculate waiting time
		for(i=1;i<n;i++)
		{
			waiting_time[i]=0;
			for(j=0;j<i;j++)
			waiting_time[i]+=burst_time[j];
			total+=waiting_time[i];
		}
		//Calculating Average waiting time
		wait_avg=(float)total/n;
		total=0;
		System.out.println("\nProcess\t Burst Time \tWaiting Time\tTurnaround Time");
		for(i=0;i<n;i++)
		{
			tat[i]=burst_time[i]+waiting_time[i];
			total+=tat[i];//Calculating TurnaroundTimetotal+=tat[i];
			System.out.println("\n p"+process[i]+"\t\t"+burst_time[i]+"\t\t"+waiting_time[i]+"\t\t "+tat[i]);
		}
		//Calculation of Average Turnaround Time
		TAT_avg=(float)total/n;
		System.out.println("\n\nAverage Waiting Time: "+wait_avg);
		System.out.println("\nAverage Turnaround Time: "+TAT_avg);
	}

}
 SPOS PRACTICAL 3 PRIORITY
//package Part1GroupB5Priority;

import java.util.Scanner;
public class Priority {
	public static void main(String args[]) {
		Scanner s = new Scanner(System.in);
		int x,n,p[],pp[],bt[],w[],t[],awt,atat,i;
		p = new int[10];
		pp = new int[10];
		bt = new int[10];
		w = new int[10];
		t = new int[10];
		//n is number of process
		//p is process
		//pp is process priority
		//bt is process burst time
		//w is wait time
		// t is turnaround time
		//awt is average waiting time
		//atat is average turnaround time
		System.out.print("Enter the number of process : ");
		n = s.nextInt();
		System.out.print("\n\t Enter burst time : time priorities \n");
		for(i=0;i<n;i++)
		{
			System.out.print("\nProcess["+(i+1)+"]:");
			bt[i] = s.nextInt();
			pp[i] = s.nextInt();
			p[i]=i+1;
		}
		//sorting on the basis of priority
		for(i=0;i<n-1;i++)
		{
			for(int j=i+1;j<n;j++)
			{
				if(pp[i]<pp[j])
				{
					x=pp[i];
					pp[i]=pp[j];
					pp[j]=x;
					x=bt[i];
					bt[i]=bt[j];
					bt[j]=x;
					x=p[i];
					p[i]=p[j];
					p[j]=x;
				}
			}
		}
		w[0]=0;
		awt=0;
		t[0]=bt[0];
		atat=t[0];
		for(i=1;i<n;i++)
		{
			w[i]=t[i-1];
			awt+=w[i];
			t[i]=w[i]+bt[i];
			atat+=t[i];
		}
		//Displaying the process
		System.out.print("\n\nProcess \t Burst Time \t Wait Time \t Turn Around Time Priority \n");
		for(i=0;i<n;i++)
			System.out.print("\n "+p[i]+"\t\t "+bt[i]+"\t\t "+w[i]+"\t\t"+t[i]+"\t\t "+pp[i]+"\n");
		
		awt/=n;
		atat/=n;
		System.out.print("\n Average Wait Time : "+awt);
		System.out.print("\n Average Turn Around Time : "+atat);
	}
}

SPOS PRACTICAL 3 SJF
//package Part1GroupB5SJF;

import java.util.Scanner;
class SJF{
	public static void main(String args[]){
		int burst_time[],process[],waiting_time[],tat[],i,j,n,total=0,pos,temp;
		float wait_avg,TAT_avg;
		Scanner s = new Scanner(System.in);
		System.out.print("Enter number of process: ");
		n = s.nextInt();
		process = new int[n];
		burst_time = new int[n];
		waiting_time = new int[n];
		tat = new int[n];
		System.out.println("\nEnter Burst time:");
		for(i=0;i<n;i++)
		{
			System.out.print("\nProcess["+(i+1)+"]: ");
			burst_time[i] = s.nextInt();;
			process[i]=i+1; //Process Number
		}
		//Sorting
		for(i=0;i<n;i++)
		{
			pos=i;
			for(j=i+1;j<n;j++)
			{
				if(burst_time[j]<burst_time[pos])
					pos=j;
			}
			temp=burst_time[i];
			burst_time[i]=burst_time[pos];
			burst_time[pos]=temp;
			temp=process[i];
			process[i]=process[pos];
			process[pos]=temp;
		}
		//First process has 0 waiting time
		waiting_time[0]=0;
		//calculate waiting time
		for(i=1;i<n;i++)
		{
			waiting_time[i]=0;
			for(j=0;j<i;j++)
				waiting_time[i]+=burst_time[j];
			total+=waiting_time[i];
		}
		//Calculating Average waiting time
		wait_avg=(float)total/n;
		total=0;
		System.out.println("\nProcess\t Burst Time \tWaiting Time\tTurnaround Time");
		for(i=0;i<n;i++)
		{
			tat[i]=burst_time[i]+waiting_time[i]; //Calculating Turnaround Time
			total+=tat[i];
			System.out.println("\n p"+process[i]+"\t\t "+burst_time[i]+"\t\t "+waiting_time[i]+"\t\t "+tat[i]);
		}
		//Calculation of Average Turnaround Time
		TAT_avg=(float)total/n;
		System.out.println("\n\nAverage Waiting Time: "+wait_avg);
		System.out.println("\nAverage Turnaround Time: "+TAT_avg);
	}

}
SPOS PRACTICAL 3 ROUND FINAL

//package Part1GroupB5Roundrobin;

import java.util.Scanner;
public class Roundfinal1 {
	public static void main(String args[]) {
		Scanner s = new Scanner(System.in);
		int wtime[],btime[],rtime[],num,quantum,total;
		wtime = new int[10];
		btime = new int[10];
		rtime = new int[10];
		System.out.print("Enter number of processes(MAX 10): ");
		num = s.nextInt();
		System.out.print("Enter burst time");
		for(int i=0;i<num;i++) 
		{ 
			System.out.print("\nP["+(i+1)+"]: "); 
			btime[i] = s.nextInt(); 
			rtime[i] = btime[i]; 
			wtime[i]=0; 
		} 
		System.out.print("\n\nEnter quantum: "); 
		quantum = s.nextInt(); 
		int rp = num; 
		int i=0; 
		int time=0; 
		System.out.print("0"); 
		wtime[0]=0; 
		while(rp!=0) { 
			if(rtime[i]>quantum)
			{
				rtime[i]=rtime[i]-quantum;
				System.out.print(" | P["+(i+1)+"] | ");
				time+=quantum;
				System.out.print(time);
			}
			else if(rtime[i]<=quantum && rtime[i]>0)
			{
				time+=rtime[i];
				rtime[i]=rtime[i]-rtime[i];
				System.out.print(" | P["+(i+1)+"] | ");
				rp--;
				System.out.print(time);
			}
			i++;
			if(i==num)
			{
				i=0;
			}
		}
	}
}

SPOS PRACTICAL 4 FIFO

package Part1GroupB7PageRepFIFO;

/* Page Replacement Policy FIFO */
import java.io.*;
public class FIFO {
 public static void main(String[] args) throws IOException
 {
 BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
 int frames, pointer = 0, hit = 0, fault = 0,ref_len;
 int buffer[];
 int reference[];
 int mem_layout[][];

 System.out.println("Please enter the number of Frames: ");
 frames = Integer.parseInt(br.readLine());

 System.out.println("Please enter the length of the Reference string: ");
 ref_len = Integer.parseInt(br.readLine());

 reference = new int[ref_len];
 mem_layout = new int[ref_len][frames];
 buffer = new int[frames];
 for(int j = 0; j < frames; j++)
 buffer[j] = -1;

 System.out.println("Please enter the reference string: ");
 for(int i = 0; i < ref_len; i++)
 {
 reference[i] = Integer.parseInt(br.readLine());
 }
 System.out.println();
 for(int i = 0; i < ref_len; i++)
 {
 int search = -1;
 for(int j = 0; j < frames; j++)
 {
 if(buffer[j] == reference[i])
 {
 search = j;
 hit++;
 break;
 }
 }
 if(search == -1)
 {
 buffer[pointer] = reference[i];
 fault++;
 pointer++;
 if(pointer == frames)
 pointer = 0;
 }
 for(int j = 0; j < frames; j++)
 mem_layout[i][j] = buffer[j];
 }

 for(int i = 0; i < frames; i++)
 {
 for(int j = 0; j < ref_len; j++)
 System.out.printf("%3d ",mem_layout[j][i]);
 System.out.println();
 }

 System.out.println("The number of Hits: " + hit);
 System.out.println("Hit Ratio: " + (float)((float)hit/ref_len));
 System.out.println("The number of Faults: " + fault);
 }

}

SPOS PRACTICAL 4 LRU

package Part1GroupB7PageRepLRU;

import java.io.*;
import java.util.*;
public class LRU {
 public static void main(String[] args) throws IOException
 {
 BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
 int frames,pointer = 0, hit = 0, fault = 0,ref_len;
 Boolean isFull = false;
 int buffer[];
 ArrayList<Integer> stack = new ArrayList<Integer>();
 int reference[];
 int mem_layout[][];

 System.out.println("Please enter the number of Frames: ");
 frames = Integer.parseInt(br.readLine());

 System.out.println("Please enter the length of the Reference string:");
 ref_len = Integer.parseInt(br.readLine());

 reference = new int[ref_len];
 mem_layout = new int[ref_len][frames];
 buffer = new int[frames];
 for(int j = 0; j < frames; j++)
 buffer[j] = -1;

 System.out.println("Please enter the reference string: ");
 for(int i = 0; i < ref_len; i++)
 {
 reference[i] = Integer.parseInt(br.readLine());
 }
 System.out.println();
 for(int i = 0; i < ref_len; i++)
 {
 if(stack.contains(reference[i]))
 {
 stack.remove(stack.indexOf(reference[i]));
 }
 stack.add(reference[i]);
 int search = -1;
 for(int j = 0; j < frames; j++)
 {
 if(buffer[j] == reference[i])
 {
 search = j;
 hit++;
 break;
 }
 }
 if(search == -1)
 {
 if(isFull)
 {
 int min_loc = ref_len;
 for(int j = 0; j < frames; j++)
{
 if(stack.contains(buffer[j]))
 {
 int temp = stack.indexOf(buffer[j]);
if(temp < min_loc)
{
 min_loc = temp;
 pointer = j;
 }
 }
 }
 }
 buffer[pointer] = reference[i];
 fault++;
 pointer++;
 if(pointer == frames)
 {
 pointer = 0;
isFull = true;
 }
 }
 for(int j = 0; j < frames; j++)
 mem_layout[i][j] = buffer[j];
 }

 for(int i = 0; i < frames; i++)
 {
 for(int j = 0; j < ref_len; j++)
 System.out.printf("%3d ",mem_layout[j][i]);
 System.out.println();
 }

 System.out.println("The number of Hits: " + hit);
 System.out.println("Hit Ratio: " + (float)((float)hit/ref_len));
 System.out.println("The number of Faults: " + fault);
 }

}

SPOS PRACTICAL 4 OPTIMAL REPLACEMENT

package Part1GroupB7OptimalPageRep;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class OptimalReplacement {
 public static void main(String[] args) throws IOException
 {
 BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
 int frames, pointer = 0, hit = 0, fault = 0,ref_len;
 boolean isFull = false;
 int buffer[];
 int reference[];
 int mem_layout[][];

 System.out.println("Please enter the number of Frames: ");
 frames = Integer.parseInt(br.readLine());

 System.out.println("Please enter the length of the Reference string:");
 ref_len = Integer.parseInt(br.readLine());

 reference = new int[ref_len];
 mem_layout = new int[ref_len][frames];
 buffer = new int[frames];
 for(int j = 0; j < frames; j++)
 buffer[j] = -1;

 System.out.println("Please enter the reference string: ");
 for(int i = 0; i < ref_len; i++)
 {
 reference[i] = Integer.parseInt(br.readLine());
 }
 System.out.println();
 for(int i = 0; i < ref_len; i++)
 {
 int search = -1;
 for(int j = 0; j < frames; j++)
 {
 if(buffer[j] == reference[i])
 {
 search = j;
 hit++;
 break;
 }
 }
 if(search == -1)
 {
 if(isFull)
 {
 int index[] = new int[frames];
 boolean index_flag[] = new boolean[frames];
 for(int j = i + 1; j < ref_len; j++)
 {
 for(int k = 0; k < frames; k++)
 {
 if((reference[j] == buffer[k]) && (index_flag[k] == false))
 {
 index[k] = j;
 index_flag[k] = true;
 break;
 }
 }
 }
 int max = index[0];
 pointer = 0;
 if(max == 0)
 max = 200;
 for(int j = 0; j < frames; j++)
 {
 if(index[j] == 0)
 index[j] = 200;
 if(index[j] > max)
 {
 max = index[j];
 pointer = j;
 }
 }
 }
 buffer[pointer] = reference[i];
 fault++;
 if(!isFull)
 {
 pointer++;
 if(pointer == frames)
 {
 pointer = 0;
 isFull = true;
 }
 }
 }
 for(int j = 0; j < frames; j++)
 mem_layout[i][j] = buffer[j];
 }

 for(int i = 0; i < frames; i++)
 {
 for(int j = 0; j < ref_len; j++)
 System.out.printf("%3d ",mem_layout[j][i]);
 System.out.println();
 }

 System.out.println("The number of Hits: " + hit);
 System.out.println("Hit Ratio: " + (float)((float)hit/ref_len));
 System.out.println("The number of Faults: " + fault);
 }

}



